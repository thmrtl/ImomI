#include "raylib.h"
#include "raymath.h"
#include "external/reasings.h"
#include <functional>
#include <print>
#include <vector>

#define PIXEL_PER_UNIT 100
#define TICK_CURVE 0.003f
#define EASE_COUNT 5

struct Entity {
    bool alive;
    bool can_move;
    Vector2 pos;
    Vector2 velocity;
    int type;
    int hp;
    int hp_max;
    float last_hit_time;
};

//--- Animation
enum class Easing {
    Linear,
    QuadIn,
    QuadInOut,
    CircIn,
    BackIn,
    Count
};

enum class Looping {
    Once,
    Linear,
    PingPong
};

struct Animation {
    Vector2 start;
    Vector2 end;
    Vector2 pos;
    float progress;
    float speed;
    int direction;
    float duration;
    bool playing;
    bool done;
    Looping looping;
    Easing easing;
};

static float Ease(float elapsed, float duration, Easing easing) {
    switch (easing) {
    case Easing::QuadIn:
        return EaseQuadIn(elapsed, 0.0f, 1.0f, duration);
    case Easing::CircIn:
        return EaseCircIn(elapsed, 0.0f, 1.0f, duration);
    case Easing::BackIn:
        return EaseBackIn(elapsed, 0.0f, 1.0f, duration);
    case Easing::QuadInOut:
        return EaseQuadInOut(elapsed, 0.0f, 1.0f, duration);
    case Easing::Linear:
    default:
        return EaseLinearIn(elapsed, 0.0f, 1.0f, duration);
    }
};

static void ResetAnimation(Animation& animation) {
    animation.progress = 0.0f;
    animation.direction = 1; // I like the behaviour rn, I could add cond. on looping type.
    animation.pos = animation.start;
    animation.playing = false;
    animation.done = false;
}

static bool UpdateAnimation(Animation& animation, float frametime) {
    if (!animation.playing) {
        return animation.done;
    }
    animation.progress += animation.speed * frametime;
    if (animation.looping == Looping::Linear) {
        animation.progress = fmodf(animation.progress, animation.duration);
    }
    else if (animation.progress >= animation.duration) {
        if (animation.looping == Looping::PingPong) {
            animation.direction *= -1;
            animation.progress = 0.0f;
        }
        else {
            animation.playing = false;
            animation.done = true;
            animation.progress = animation.duration;
        }
    }
    float progress = animation.direction == 1 ? animation.progress : animation.duration - animation.progress;
    float t = Ease(progress, animation.duration, animation.easing);
    animation.pos = Vector2Lerp(animation.start, animation.end, t);
    return animation.done;
};

int main() {
    InitWindow(800, 450, "ImomI");
    SetTargetFPS(60);

    float screen_width = (float)GetScreenWidth();
    float screen_height = (float)GetScreenHeight();
    Vector2 resolution{screen_width, screen_height};

    Camera2D camera;
    Entity player;

    auto reset = [&]() {
        camera = {
            .offset = { screen_width * 0.5f, screen_height * 0.5f },
            .target = { 0.0f, 0.0f },
            .rotation = 0.0f,
            .zoom = 1.0f,
        };

        player = {
            .alive = true,
            .can_move = true,
            .pos = { -screen_width * 0.5f, screen_height * 0.15f },
            .velocity = { 360.0f, 360.0f },
        };
    };

    auto draw_entity = [](Entity const& entity, Vector2 size, Color color)
    {
        int x = int(round(entity.pos.x - size.x * 0.5f));
        int y = int(round(entity.pos.y - size.y * 0.5f));
        int width = int(round(size.x));
        int height = int(round(size.y));
        DrawRectangle(x, y, width, height, color);
    };

    struct Timer {
        bool running;
        bool run_once;
        float elapsed;
        float duration;
    };

    auto update_timer = [](Timer& timer, float frametime, std::function<void()> on_tick = {}) {
        if (!timer.running) {
            return;
        }
        timer.elapsed += frametime;
        while (timer.running && timer.elapsed >= timer.duration) {
            timer.elapsed -= timer.duration;
            if (on_tick) {
                on_tick();
            }
            if (timer.run_once) {
                timer.running = false;
                break;
            }
        }
    };

    auto reset_timer = [](Timer& timer) {
        timer.elapsed = 0.0f,
        timer.running = true;
    };

    reset();
    float duration = 2.0f;
    int n_points = 100;
    int i_points = 0;
    std::vector<Vector2> points(n_points + 1);
    float elapsed_time = 0.0f;
    Animation portal_animation{
        .start = { 2, -5 },
        .end = { 8, -3 },
        .pos = { 2, -5 },
        .progress = 0.0f,
        .speed = 1.0f,
        .direction = 1,
        .duration = duration,
        .playing = false,
        .looping = Looping::Linear,
        .easing = Easing::Linear,
    };
    Timer timer_curve{
        .running = true,
        .run_once = false,
        .elapsed = 0.0f,
        .duration = 0.003f,
    };

    auto update_curve_values = [&]() {
        if (i_points > n_points) {
            timer_curve.running = false;
            return;
        }
        float t = i_points * duration / n_points;
        points[i_points].x = t;
        points[i_points].y = Ease(t, duration, portal_animation.easing);
        i_points++;
    };

    while (!WindowShouldClose()) {
        screen_width = (float)GetScreenWidth();
        screen_height = (float)GetScreenHeight();
        float frametime = GetFrameTime();

        //--- Logic
        if (IsKeyDown(KEY_W)) {
            player.pos.y -= player.velocity.y * frametime;
        }
        if (IsKeyDown(KEY_A)) {
            player.pos.x -= player.velocity.x * frametime;
        }
        if (IsKeyDown(KEY_S)) {
            player.pos.y += player.velocity.y * frametime;
        }
        if (IsKeyDown(KEY_D)) {
            player.pos.x += player.velocity.x * frametime;
        }
        if (IsKeyDown(KEY_I)) {
            camera.target.y -= 500.0f * frametime;
        }
        if (IsKeyDown(KEY_J)) {
            camera.target.x -= 500.0f * frametime;
        }
        if (IsKeyDown(KEY_K)) {
            camera.target.y += 500.0f * frametime;
        }
        if (IsKeyDown(KEY_L)) {
            camera.target.x += 500.0f * frametime;
        }
        if (IsKeyDown(KEY_COMMA)) {
            camera.zoom -= 0.05f;
            camera.zoom = Clamp(camera.zoom, 0.5f, 2.0f);
        }
        if (IsKeyDown(KEY_M)) {
            camera.zoom += 0.05f;
            camera.zoom = Clamp(camera.zoom, 0.5f, 2.0f);
        }
        if (IsKeyPressed(KEY_N)) {
            camera.zoom = 1.0f;
            camera.target.x = 0.0f;
            camera.target.y = 0.0f;
        }
        if (IsKeyPressed(KEY_LEFT)) {
            portal_animation.easing = Easing(int(portal_animation.easing) + 1);
            if (portal_animation.easing == Easing::Count) {
                portal_animation.easing = Easing::Linear;
            }
            reset_timer(timer_curve);
            i_points = 0;
        }
        if (IsKeyPressed(KEY_RIGHT)) {
            if (portal_animation.easing == Easing::Linear) {
                portal_animation.easing = Easing::BackIn;
            }
            else {
                portal_animation.easing = Easing(int(portal_animation.easing) - 1);
            }
            reset_timer(timer_curve);
            i_points = 0;
        }
        if (IsKeyPressed(KEY_SPACE)) {
            if (portal_animation.done) {
                ResetAnimation(portal_animation);
                portal_animation.playing = true;
            }
            else {
                portal_animation.playing = !portal_animation.playing;
            }
            player.can_move = !portal_animation.playing;
        }
        if (IsKeyPressed(KEY_V)) {
            switch (portal_animation.looping)
            {
            case Looping::Linear:
                portal_animation.looping = Looping::Once;
                break;
            case Looping::Once:
                portal_animation.looping = Looping::PingPong;
                break;
            case Looping::PingPong:
                portal_animation.looping = Looping::Linear;
                break;
            }
        }
        
        if (IsMouseButtonPressed(MOUSE_BUTTON_MIDDLE)) {
            camera.zoom = 1.0f;
            camera.target.x = 0.0f;
            camera.target.y = 0.0f;
        }
        if (IsMouseButtonDown(MOUSE_BUTTON_LEFT)) {
            camera.target -= GetMouseDelta() / camera.zoom;
        }
        Vector2 mouse_wheel = GetMouseWheelMoveV();
        if (mouse_wheel.y > 0) {
            camera.zoom += 0.1f;
            camera.zoom = Clamp(camera.zoom, 0.5f, 2.0f);
        }
        if (mouse_wheel.y < 0) {
            camera.zoom -= 0.1f;
            camera.zoom = Clamp(camera.zoom, 0.5f, 2.0f);
        }

        if (i_points != -1 && i_points <= n_points) {
            update_timer(timer_curve, frametime, update_curve_values);
        }

        elapsed_time += frametime;
        if (elapsed_time > duration) {
            elapsed_time = 0.0f;
        }

        if (portal_animation.playing) {
            if (UpdateAnimation(portal_animation, frametime)) {
                std::println("Once");
            }
            player.pos = portal_animation.pos * PIXEL_PER_UNIT;
        }

        //--- Drawing
        BeginDrawing();
            ClearBackground(BLACK);

            auto tl = GetScreenToWorld2D({0.0f, 0.0f}, camera);
            auto br = GetScreenToWorld2D(resolution, camera);
            auto left = GetWorldToScreen2D({tl.x, 0}, camera);
            auto right = GetWorldToScreen2D({br.x, 0}, camera);
            auto top = GetWorldToScreen2D({0, tl.y}, camera);
            auto bottom = GetWorldToScreen2D({0, br.y}, camera);
            DrawLine(lroundf(left.x), lroundf(left.y), lroundf(right.x), lroundf(right.y), RED);
            DrawLine(lroundf(top.x), lroundf(top.y), lroundf(bottom.x), lroundf(bottom.y), GREEN);

            BeginMode2D(camera);
                int n_ylines = int((br.x - tl.x) / PIXEL_PER_UNIT) + 1;
                int n_xlines = int((br.y - tl.y) / PIXEL_PER_UNIT) + 1;
                for (int i = 0; i <= std::max(n_xlines, n_ylines); i++) {
                    float x = (i * 1.0f + int((tl.x + PIXEL_PER_UNIT * 0.5f) / PIXEL_PER_UNIT)) * PIXEL_PER_UNIT;
                    float y = (i * 1.0f + int((tl.y + PIXEL_PER_UNIT * 0.5f) / PIXEL_PER_UNIT)) * PIXEL_PER_UNIT;
                    if (x != 0) {
                        DrawLine(lroundf(x), lroundf(tl.y), lroundf(x), lroundf(br.y), GRAY);
                    }
                    if (y != 0) {
                        DrawLine(lroundf(tl.x), lroundf(y), lroundf(br.x), lroundf(y), GRAY);
                    }
                }
            EndMode2D();

            auto origin =  GetWorldToScreen2D({0, 0}, camera);
            bool origin_x_is_out = origin.x < 0 || origin.x >= screen_width;
            bool origin_y_is_out = origin.y < 0 || origin.y >= screen_height;
            if (origin_x_is_out || origin_y_is_out) {
                origin.x = Clamp(origin.x, 5, screen_width - 5);
                origin.y = Clamp(origin.y, 5, screen_height - 5);
                if (origin_x_is_out && origin_y_is_out) {
                    DrawCircleSector(origin, 5, 0, 180, 6, RED);
                    DrawCircleSector(origin, 5, 180, 360, 6, GREEN);
                }
                else {
                    DrawCircle(int(origin.x), int(origin.y), 5, origin_x_is_out ? RED : GREEN);
                }
            }

            BeginMode2D(camera);
                draw_entity(player, { 30.0f , 30.0f }, LIGHTGRAY);
                if (i_points != -1) {
                    float x0 = roundf(points[0].x * PIXEL_PER_UNIT);
                    float y0 = roundf(points[0].y * PIXEL_PER_UNIT);
                    DrawCircle(int(x0), int(y0), 5, WHITE);
                    for (int i = 1; i <= std::min(i_points, n_points); i++) {
                        float xi = roundf(points[i].x * PIXEL_PER_UNIT);
                        float yi = -roundf(points[i].y * PIXEL_PER_UNIT);
                        float xj = roundf(points[i - 1].x * PIXEL_PER_UNIT);
                        float yj = -roundf(points[i - 1].y * PIXEL_PER_UNIT);
                        DrawLine(int(xi), int(yi), int(xj), int(yj), WHITE);
                        DrawCircle(int(xi), int(yi), 1, WHITE);
                    }
                }

                float xa = 0;
                float xb = duration * PIXEL_PER_UNIT;
                float ya = -1.0f * PIXEL_PER_UNIT;
                for (int i = 0; i < 5; i++) {
                    float t = fmodf(elapsed_time + i * duration / 5, duration);
                    float e = Ease(t, duration, portal_animation.easing);
                    float x = roundf(t * PIXEL_PER_UNIT);
                    float y = -roundf(e * PIXEL_PER_UNIT);
                    DrawCircle(int(x), int(y), 5, RED);
                    float r = Lerp(xa, xb, e);
                    float s = Lerp(0, ya, e);
                    DrawCircle(int(r), int(ya), 5, RED);
                    DrawCircle(int(xb), int(s), 5, RED);
                }
                
                Vector2 p{2, 5};
                Vector2 q{8, 3};
                for (int i = 0; i < 5; i++) {
                    float t = fmodf(elapsed_time + i * duration / 5, duration);
                    float e = Ease(t, duration, portal_animation.easing);
                    Vector2 pos = Vector2Lerp(p, q, e);
                    DrawCircle(int(pos.x * PIXEL_PER_UNIT), int(-pos.y * PIXEL_PER_UNIT), 5, RED);
                }
            EndMode2D();
        EndDrawing();
    }
}